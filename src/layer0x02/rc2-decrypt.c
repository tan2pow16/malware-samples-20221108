/*
 * Copyright (c) 2022, Tangent65536.
 *  All rights reserved.
 */

#include <fcntl.h>
#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <wincrypt.h>

typedef struct _PLAINTEXTKEYBLOB
{
  BLOBHEADER hdr;
  DWORD dwKeySize;
  BYTE rgbKeyData[];
} _PLAINTEXTKEYBLOB;

static void print_key(HCRYPTKEY *handleKey)
{
  DWORD blob_len;
  LPBYTE blob;
  uint32_t i;
  _PLAINTEXTKEYBLOB *key_blob;

  if(!CryptExportKey(*handleKey, 0, PLAINTEXTKEYBLOB, 0, NULL, &blob_len))
  {
    return;
  }

  if(!(blob = malloc(blob_len)))
  {
    return;
  }

  if(!CryptExportKey(*handleKey, 0, PLAINTEXTKEYBLOB, 0, blob, &blob_len))
  {
    return;
  }

  key_blob = (_PLAINTEXTKEYBLOB *)blob;
  fprintf(stderr, "Derived Key: ");
  for(i = 0 ; i < key_blob->dwKeySize ; i++)
  {
    fprintf(stderr, "%02x", *(uint8_t *)(key_blob->rgbKeyData + i));
  }
  fprintf(stderr, "\n");

  free(blob);
}

static uint32_t decrypt_data(uint8_t *data, uint32_t data_len, uint8_t *passwd, uint8_t pass_len)
{
  HCRYPTPROV handleProv;
  HCRYPTHASH handleHash;
  HCRYPTKEY handleKey;

  // PROV_RSA_AES         ->         24
  // CRYPT_VERIFYCONTEXT  -> 0xF0000000
  if(!CryptAcquireContext(&handleProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
  {
    fprintf(stderr, "CryptAcquireContext() failed.\n");
    return 0;
  }

  // CALG_MD5  -> 0x00008003
  if(!CryptCreateHash(handleProv, CALG_MD5, 0, 0, &handleHash))
  {
    fprintf(stderr, "CryptCreateHash() failed.\n");
    return 0;
  }

  // The last arg is always 1 according to M$
  if(!CryptHashData(handleHash, passwd, pass_len, 0x1))
  {
    fprintf(stderr, "CryptHashData() failed.\n");
    return 0;
  }

  // CALG_RC2          -> 0x00006602
  // CRYPT_EXPORTABLE  -> 0x1
  if(!CryptDeriveKey(handleProv, CALG_RC2, handleHash, CRYPT_EXPORTABLE, &handleKey))
  {
    fprintf(stderr, "CryptDeriveKey() failed.\n");
    return 0;
  }

  if(!CryptDecrypt(handleKey, 0, TRUE, 0, data, (DWORD *)&data_len))
  {
    fprintf(stderr, "CryptDecrypt() failed.\n");
    return 0;
  }

  print_key(&handleKey);

  CryptDestroyKey(handleKey);
  CryptDestroyHash(handleHash);

  return data_len;
}

static uint32_t read_file(uint8_t *path, uint8_t **ret)
{
  FILE *file;
  uint32_t size;

  file = fopen(path, "rb");
  if(!file)
  {
    fprintf(stderr, "fopen() failed. Is the file path valid?\n");
    return 0;
  }

  fseek(file, 0, SEEK_END);
  size = ftell(file);
  fseek(file, 0, SEEK_SET);

  if(!(*ret = malloc(size + 1)))
  {
    fprintf(stderr, "malloc() failed.\n");
    return 0;
  }

  fread(*ret, size, 1, file);
  (*ret)[size] = 0; // We are dealing with a hex c'string'.

  fclose(file);

  return size;
}

static uint32_t autoit_hex_decode(uint8_t *cstr, uint8_t **ret)
{
  const uint8_t char_map[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  };
  uint32_t ilen, olen, i, j;

  ilen = strlen(cstr);

  // (x & 1) -> Determine if 'x' is odd
  if((ilen & 1) || cstr[0] != '0' || cstr[1] != 'x')
  {
    fprintf(stderr, "Invalid AutoIt hex literal. Abort.\n");
    return 0;
  }

  // (x >> 1) -> Equiv. to (x / 2)
  olen = (ilen >> 1) - 1;
  if(!(*ret = malloc(olen)))
  {
    fprintf(stderr, "malloc() failed.\n");
    return 0;
  }

  for(i = 2, j = 0 ; j < olen ; j++)
  {
    (*ret)[j] = (char_map[cstr[i + 1]] | (char_map[cstr[i]] << 4));
    i += 2;
  }

  return olen;
}

int main(int argc, uint8_t *argv[])
{
  uint32_t len;
  uint8_t *file_path, *passwd, *buf1, *buf2;

  if(argc < 3)
  {
    if(argc <= 0)
    {
      fprintf(stderr, "Invalid runtime environment.\n");
    }
    else
    {
      fprintf(stderr, "Usage: %s <hex-file-path> <key>\n", argv[0]);
    }
    return 0;
  }

  file_path = argv[1];
  passwd = argv[2];

  if(!read_file(file_path, &buf1))
  {
    fprintf(stderr, "Unable to read the input file.\n");
    return 1;
  }
  strrev(buf1);

  if(!(len = autoit_hex_decode(buf1, &buf2)))
  {
    fprintf(stderr, "Unable to decode the input file.\n");
    return 1;
  }
  free(buf1);

  if(!(len = decrypt_data(buf2, len, passwd, strlen(passwd))))
  {
    fprintf(stderr, "Unable to decrypt the payload.\n");
    return 1;
  }
  setmode(fileno(stdout), O_BINARY);
  fwrite(buf2, len, 1, stdout);
  free(buf2);

  return 0;
}
